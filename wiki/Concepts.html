<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en" xmlns="http://www.w3.org/1999/html"><!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <title>Concepts |  OrientDB</title>
  <title>Concepts</title>
  <link href="../stylesheets/foundation.min.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../stylesheets/app.css" media="screen" rel="stylesheet" type="text/css" />
  <script src="../javascripts/modernizr.foundation.js" type="text/javascript"></script>
  
</head>
<body class="orientdb orientdb_wiki orientdb_wiki_Concepts">

<header>
  <div class="row">
    <div class="five columns">
      <h1>
        <a href="/orientdb/">
          Orient<span class="highl">DB</span>
        </a>
        <span class="subtitle">The Document/Graph NoSQL Database</span>
      </h1>
    </div>
    <div class="seven columns right">
      <ul class="inline-list">
        <li><a href="/orientdb/"> Home</a></li>
<li><a href="/orientdb/about.html"> About</a></li>
<li class="active"><a href="/orientdb/wiki/Home.html"> Documentation</a></li>
<li><a href="/orientdb/wiki/Download.html"> Downloads</a></li>
<li><a href="/orientdb/community.html"> Community</a></li>
      </ul>
    </div>
  </div>
</header>


<div class="page-header">
  <div class="row">
    <div class="twelve columns">
      <h2>
        <i class="icon-orientdb"></i>
        Concepts
        
          <ul class="bcs">
          
            <li><a href="/orientdb/wiki/Home.html" class="nr1">Home</a></li>
          
          </ul>
        
        
      </h2>
    </div>
  </div>
</div>

<div id="main" class="row wiki">

  <div class="twelve columns content" role="content">

    <h3><u>Storage</u></h3>

<p>It's the real physical database. It can be:</p>

<ul>
<li>
<strong>local</strong>, where the access is made in the same process</li>
<li>
<strong>remote</strong>, by using the network to access a remote storage</li>
<li>
<strong>memory</strong>, all data remain in memory without to use the file system at all</li>
</ul><p>A Storage is composed of multiple <a href="#Cluster">Cluster</a> and <a href="#Data_Segment">Data Segments</a>. You <em>must</em> move real files in your file system only by using the OrientDB APIs to avoid data corruption.</p>

<p><img src="http://www.orientechnologies.com/images/orientdb-storage.png"></p>

<h3><u>Cluster</u></h3>

<p>OrientDB uses <strong>clusters</strong> to store links to the data. A cluster is a very generic way to group records and it is a concept that does not exists in the Relational world. You can use a cluster to group all the record of a certain type, or by a specific value. Example:</p>

<ul>
<li>Use the cluster "Person" to group all the records of type "Person". This approach is similar to the RDBMS where each table is a cluster.</li>
<li>Use the cluster "Cache" to group all the records most accessed.</li>
<li>Use the cluster "Today" to group all the record created today</li>
<li>Use the cluster "!CityCar" to group all the city cars</li>
</ul><p>These are some examples about the clustering concepts. If you have a background from the Relational DBMS world, you can think of a cluster like a table and use it to group all the records by types.</p>

<p>A cluster can be local (physical) or in-memory. </p>

<p><strong>Note: Logical Clusters are not supported anymore since 1.0.</strong></p>

<h4>Local Physical Cluster</h4>

<p>The cluster is mapped 1-by-2 to files in the underlying File System. The local physical cluster uses two or more files: One or more files with extension "ocl" (OrientDB Cluster) and only one file with extension "och" (OrientDB Cluster Holes).</p>

<p>For example, if you create the "Person" cluster, the following files will be created in the folder that contains your database:</p>

<ul>
<li>person.0.ocl</li>
<li>person.och</li>
</ul><p>The first file contains the pointers to the record content in ODA (OrientDB Data Segment). The '0' in the name indicates that more successive data files can be created for this cluster. You can split a physical cluster into multiple real files. This behavior depends on your configuration. When a cluster file is full, a new file will be used. </p>

<p>The second file is the "Hole" file that stores the holes in the cluster that were generated by deleted data.</p>

<p>NOTE : You can move real files in your file system only by using the OrientDB APIs.</p>

<h4>In-Memory cluster</h4>

<p>The information stored in this kind of cluster is volatile and is never stored on disk. Use this cluster only to work with temporary data. If you need an In-Memory database, create it as an In-memory Database. In-memory databases have only In-memory clusters.</p>

<h3>Data Segment</h3>

<p>OrientDB uses <strong>data segments</strong> to store the record content. The data segment behaves similar to the physical cluster files: it uses two or more files. One or multiple files with the extension "oda" (OrientDB DAta) and only one file with the extension "odh" (OrientDB Data Holes).</p>

<p>By default OrientDB creates the first data segment named "default". In the folder that contains your database you will find the following files:</p>

<ul>
<li>default.0.oda</li>
<li>default.odh</li>
</ul><p>The first file is the one that contains the real data. The '0' in the name indicates that more successive data files can be created for this cluster. You can split a data segment into multiple real files. This behavior depends on your configuration. When a data segment file is full, a new file will be used.</p>

<p><strong>NOTE: You can move real files in your file system only by using the OrientDB APIs.</strong></p>

<p>Interaction between components: load record use case:</p>

<p><img src="http://www.orientechnologies.com/images/orientdb-loadrecord.png"></p>

<h3>Record</h3>

<p>A record is the smallest unit that can be loaded from - and stored into the database.</p>

<h4>Record types</h4>

<p>There are several types of records.</p>

<h5>Document</h5>

<p>It's the most flexible record available in OrientDB. It's softly typed.  Types are the schema classes with the defined constraints, but can be  used also in schema-less mode. It handles fields in a flexible way. A  document can be easily imported and exported in JSON format.
Example of a Document in JSON format:
</p><div class="highlight"><pre>  <span class="o">{</span>
    <span class="s">"name"</span><span class="o">:</span> <span class="s">"Jay"</span><span class="o">,</span>
    <span class="s">"surname"</span><span class="o">:</span> <span class="s">"Miner"</span><span class="o">,</span>
    <span class="s">"job"</span><span class="o">:</span> <span class="s">"Developer"</span><span class="o">,</span>
    <span class="s">"creations"</span><span class="o">:</span> <span class="o">[</span>
      <span class="o">{</span> <span class="s">"name"</span><span class="o">:</span> <span class="s">"Amiga 1000"</span><span class="o">,</span>
        <span class="s">"company"</span><span class="o">:</span> <span class="s">"Commodore Inc."</span>
      <span class="o">},</span>
      <span class="o">{</span> <span class="s">"name"</span><span class="o">:</span> <span class="s">"Amiga 500"</span><span class="o">,</span>
        <span class="s">"company"</span><span class="o">:</span> <span class="s">"Commodore Inc."</span>
      <span class="o">}</span>
    <span class="o">]</span>
  <span class="o">}</span>
</pre></div>
OrientDB Documents support complex <a href="#Relationships">relationships</a>. From a programmer's perspective this can be seen as a sort of persistent Map.

<h5>Flat</h5>

<p>Records are strings. No fields are supported, no indexing, no schema.</p>

<h4>RecordID</h4>

<p>In OrientDB, each record has a unique ID. The RecordID is composed in this way:
{{{#[Where:</p>

<ul>
<li>cluster, is the cluster id. Positive numbers mean <a>#Physical_Cluster physical clusters</a>. Negative numbers mean temporary records, like those used in result set for queries when using projections.</li>
<li>position, is the absolute position of the record inside a cluster.</li>
</ul><p><em>NOTE: After the release 1.0rc4 the prefix character # is mandatory to recognize a RecordID.</em></p>

<p>The record never looses its identity unless is deleted. Once deleted its identity could be recycled and assigned to a new record. See the <a href="#Inverse_relationships">Inverse relationships</a> to know more about this.</p>

<p>You can access a record directly by its RecordID. For this reason you don't need to create a field as a primary key like in a Relational DBMS.</p>

<h4>Record version</h4>

<p>Each record maintains its own version number that is incremented at every update. When a record is created, the version is zero. In optimistic transactions the version is checked in order to avoid conflicts at commit time.</p>

<h3>Class</h3>

<p>A Class is a concept taken from the <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">Object Oriented paradigm</a>. In OrientDB defines a type of record. It's the closest concept to a Relational DBMS Table. Class can be schema-less, schema-full or mixed.</p>

<p>A class can inherit from another, shaping a tree of classes. <a href="http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming">Inheritance</a>) means that the sub-class extends the parent one, inheriting all the attributes.</p>

<p>Each class has its <a href="#Cluster">clusters</a>. A class must have at least one cluster defined (its default cluster), but can support multiple ones. In this case by default OrientDB will write new records in the default cluster, but reads will always involve all the defined clusters.</p>

<p>When you create a new class by default a new <a href="#Physical_Cluster">physical cluster</a> is created with the same name of the class in lowercase.</p>

<h4>Abstract Class</h4>

<p>If you know Object Orientation you already know what is an abstract class. For all the rest:</p>

<ul>
<li><a href="http://en.wikipedia.org/wiki/Abstract_type">http://en.wikipedia.org/wiki/Abstract_type</a></li>
<li>
<a href="http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html">http://docs.oracle.com/javase/tutorial/java/IandI/abstract.html</a>
In few words is a class can't have instances and it's used, usually, as base class to extend by concrete classes.</li>
</ul><p>To create a new abstract class look at [Abstract classes are useful to support Object Orientation at 100% without spamming the database with always empty auto-created clusters.
<em>NOTE: available since 1.2.0</em></p>

<h4>When to use class or cluster in queries?</h4>

<p>Look at this example: you create the class "Invoice" and the 2 clusters "invoice2011" and "invoice2012". This allow to query all the invoices by using the class as target in SQL select:
</p><div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="n">Invoice</span>
</pre></div>
If you want to filter per year 2012 and you've create a "year" field in Invoice class do:
<div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="n">Invoice</span> <span class="n">where</span> <span class="n">year</span> <span class="o">=</span> <span class="mi">2012</span>
</pre></div>
But splitting the Class Invoice in multiple clusters and inserting the invoice in the right cluster, one per year, allows you to reach the same goal using:
<div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="nl">cluster:</span><span class="n">invoice2012</span>
</pre></div>
This is much faster because OrientDB doesn't need to browse all the cluster but only the right one-

<p>The combination Class/Cluster is very powerful and allows to resolve many use cases.</p>

<h3>Relationships</h3>

<p>OrientDB supports two kind of relationships: <em>referenced</em> and <em>embedded</em>. OrientDB can manage relationships in a <a class="internal present" href="/orientdb/wiki/SQL-Create-Class.html#abstract_class">http://code.google.com/p/orient/wiki/Schema#Define_relationships Schema</a>.]] or in Schema-less scenario.</p>

<h4>Referenced relationships</h4>

<p>Relationships in OrientDB are managed natively without computing costly JOINs as in the Relational DBMSs. In fact OrientDB stores the direct link(s) to the target objects of the relationship. This boost up the load of entire graph of connected objects like in Graph and Object DBMSs.
Example:
</p><div class="highlight"><pre>                    <span class="n">customer</span>
    <span class="n">Record</span> <span class="n">A</span>     <span class="o">-------------&gt;</span>    <span class="n">Record</span> <span class="n">B</span>
  <span class="n">CLASS</span><span class="o">=</span><span class="n">Invoice</span>                 <span class="n">CLASS</span><span class="o">=</span><span class="n">Customer</span>
    <span class="n">RID</span><span class="o">=</span><span class="mi">5</span><span class="o">:</span><span class="mi">23</span>                       <span class="n">RID</span><span class="o">=</span><span class="mi">10</span><span class="o">:</span><span class="mi">2</span>
</pre></div>

<p><b>Record A</b> will contain the <em>reference</em> to <strong>Record B</strong> in the property called "customer". Note that both records are reachable by other records since they have a <a href="#RecordID">RecordID</a>.</p>

<h5>1-1 and N-1 referenced relationships</h5>

<p>This kind of relationships are expressed using the <strong>LINK</strong> type.</p>

<h5>1-N and N-M referenced relationships</h5>

<p>This kind of relationships are expressed using the collection of links such as:</p>

<ul>
<li>
<strong>LINKLIST</strong>, as an ordered list of links</li>
<li>
<strong>LINKSET</strong>, as an unordered set of links. It doesn't accepts duplicates</li>
<li>
<strong>LINKMAP</strong>, as an ordered map of links with key a <strong>String</strong>. It doesn't accepts duplicated keys</li>
</ul><h4>Embedded relationships</h4>

<p>Embedded records, instead, are contained inside the record that embeds them. It's a kind of relationship stronger than the <a href="#Referenced_relationships">reference</a>. It can be represented like the <a href="http://en.wikipedia.org/wiki/Class_diagram#Composition">UML Composition relationship</a>. The embedded record will not have an own <a href="#RecordID">RecordID</a>, since it can't be directly referenced by other records. It's only accessible through the container record. If the container record is deleted, then the embedded record will be deleted too. Example:
</p><div class="highlight"><pre>                    <span class="n">address</span>
    <span class="n">Record</span> <span class="n">A</span>     <span class="o">&lt;&gt;----------&gt;</span>   <span class="n">Record</span> <span class="n">B</span>
  <span class="n">CLASS</span><span class="o">=</span><span class="n">Account</span>               <span class="n">CLASS</span><span class="o">=</span><span class="n">Address</span>
    <span class="n">RID</span><span class="o">=</span><span class="mi">5</span><span class="o">:</span><span class="mi">23</span>                     <span class="n">NO</span> <span class="n">RID</span><span class="o">!</span>
</pre></div>
<b>Record A</b> will contain the entire <strong>Record B</strong> in the property called "address". <strong>Record B</strong> can be reached only by traversing the container record.

<p>Example:
</p><div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="n">account</span> <span class="n">WHERE</span> <span class="n">address</span><span class="o">.</span><span class="na">city</span> <span class="o">=</span> <span class="err">'</span><span class="n">Rome</span><span class="err">'</span>
</pre></div>

<h5>1-1 and N-1 embedded relationships</h5>

<p>This kind of relationships are expressed using the <strong>EMBEDDED</strong> type.</p>

<h5>1-N and N-M embedded relationships</h5>

<p>This kind of relationships are expressed using the collection of links such as:</p>

<ul>
<li>
<b>EMBEDDEDLIST</b>, as an ordered list of records</li>
<li>
<b>EMBEDDEDSET</b>, as an unordered set of records. It doesn't accepts duplicates</li>
<li>
<b>EMBEDDEDMAP</b>, as an ordered map of records as value with key a <strong>String</strong>. It doesn't accepts duplicated keys</li>
</ul><h4>Inverse relationships</h4>

<p>Until support for Inverse Relationships is implemented natively, the application developer is responsible for maintinaing their integrity. (See issue [For this reason when a relationship is changed, the developer needs to update the referenced object by hand, removing the back relationship to the original.</p>

<h3>Database</h3>

<p>A database is an interface to access to the real <a href="http://code.google.com/p/orient/issues/detail?id=7%5D">#Storage Storage</a>.). The database knows all the high-level concepts such as Query, Schema, Metadata, Indexes, etc. OrientDB provides multiple database types. Take a look to the <a class="internal present" href="/orientdb/wiki/Java-API.html#database_types">Database types</a> to know more about it.</p>

<p>Each server or JVM can handle multiple database instance, but the database name must be UNIQUE. So you can't manage at the same time 2 databases named "customer" in 2 different paths. To handle this case use the $ (dollar) as separator instead of / (slash). OrientDB will bind the entire name, so it will be unique, but at the file system level it will convert $ with / allowing multiple databases with the same name in different paths. Example:
</p><div class="highlight"><pre>  <span class="n">test$customers</span> <span class="o">-&gt;</span> <span class="n">test</span><span class="o">/</span><span class="n">customers</span>
  <span class="n">production$customers</span> <span class="o">=</span> <span class="n">production</span><span class="o">/</span><span class="n">customers</span>
</pre></div>
The database must be opened as:
<div class="highlight"><pre>  <span class="n">test</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ODatabaseDocumentTx</span><span class="o">(</span><span class="s">"remote:localhost/test$customers"</span><span class="o">);</span>
  <span class="n">production</span> <span class="o">=</span>  <span class="n">ODatabaseDocumentTx</span><span class="o">(</span><span class="s">"remote:localhost/production$customers"</span><span class="o">);</span>
</pre></div>

<h4>Database URL</h4>

<p>OrientDB has its own <a href="http://en.wikipedia.org/wiki/Uniform_Resource_Locator">URL</a> format:</p>

<div class="highlight"><pre>  <span class="nt">&lt;engine&gt;</span>:<span class="nt">&lt;db-name&gt;</span>
</pre></div>

<p>Where:</p>

<ul>
<li>
<strong>db-name</strong> is the database name and depends on the engine used (see below)</li>
<li>
<strong><a href="http://code.google.com/p/orient/wiki/JavaAPI#Engines">engine</a></strong> can be:</li>
</ul><table>
<tr>
<th>Engine</th>
<th>Description</th>
<th>Example</th>
</tr>
<tr>
<td>remote</td>
<td>The storage will be opened via remote network connection. It requires a OrientDB Server up and running. In this mode, the database is shared among multiple clients. Syntax: <code>remote:&lt;server&gt;:[&lt;port&gt;]/db-name</code>. The port is optional and if not specified is 2480.</td>
<td>remote:localhost/petshop</td>
</tr>
<tr>
<td>local</td>
<td>Direct access via the local File System using the path. In this configuration OrientDB runs as embedded. The database can't be opened by multiple processes (if you want this you have to use "remote" instead). It's the fastest access because it avoids any network connection and transfers</td>
<td>local:C:/temp/databases/petshop/petshop</td>
</tr>
<tr>
<td>memory</td>
<td>Open a database completely in memory</td>
<td>memory:petshop</td>
</tr>
</table><h4>Database usage</h4>

<p>The database must always be closed once you've finished working with it.</p>

<p>NOTE: OrientDB automatically closes all opened storages when the process dies softly (not by force killing). This is assured if the Operating System allows a graceful shutdown.</p>


  </div>

</div>

<footer>
  <div class="row">
    <div class="six columns">
      <ul class="inline-list">
        <li><a href="/orientdb/"> Home</a></li>
<li><a href="/orientdb/about.html"> About</a></li>
<li class="active"><a href="/orientdb/wiki/Home.html"> Documentation</a></li>
<li><a href="/orientdb/wiki/Download.html"> Downloads</a></li>
<li><a href="/orientdb/community.html"> Community</a></li>
      </ul>
    </div>
    <div class="six columns">
      <p class="copyright">
        Copyright &copy; 2011-2012 NuvolaBase Ltd. <br/>
        <span class="small">NuvolaBase is a registered trademark. All Rights Reserved.</span>
      </p>
    </div>
  </div>
</footer>

<script src="../javascripts/app.js" type="text/javascript"></script>

</body>
</html>