<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en" xmlns="http://www.w3.org/1999/html"><!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <title>Pivoting With Query |  OrientDB</title>
  <title>Pivoting With Query</title>
  <link href="../stylesheets/foundation.min.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../stylesheets/app.css" media="screen" rel="stylesheet" type="text/css" />
  <script src="../javascripts/modernizr.foundation.js" type="text/javascript"></script>
  
</head>
<body class="orientdb orientdb_wiki orientdb_wiki_Pivoting-With-Query">

<header>
  <div class="row">
    <div class="five columns">
      <h1>
        <a href="/orientdb/">
          Orient<span class="highl">DB</span>
        </a>
        <span class="subtitle">The Document/Graph NoSQL Database</span>
      </h1>
    </div>
    <div class="seven columns right">
      <ul class="inline-list">
        <li><a href="/orientdb/"> Home</a></li>
<li><a href="/orientdb/about.html"> About</a></li>
<li class="active"><a href="/orientdb/wiki/Home.html"> Documentation</a></li>
<li><a href="/orientdb/wiki/Download.html"> Downloads</a></li>
<li><a href="/orientdb/community.html"> Community</a></li>
      </ul>
    </div>
  </div>
</header>


<div class="page-header">
  <div class="row">
    <div class="twelve columns">
      <h2>
        <i class="icon-orientdb"></i>
        Pivoting With Query
        
          <ul class="bcs">
          
            <li><a href="/orientdb/wiki/Home.html" class="nr1">Home</a></li>
          
          </ul>
        
        
      </h2>
    </div>
  </div>
</div>

<div id="main" class="row wiki">

  <div class="twelve columns content" role="content">

    <h3>Determining the pivot class on select queries</h3>

<p>When planning a <a class="internal present" href="/orientdb/wiki/SQL-Query.html">SELECT</a> OrientDB query is important to determine the model class that will be taken as pivot class of the query. This class is expressed in the 'from' clause. It affects other elements in the query as follows:</p>

<ul>
<li>projections will be referred to the pivot class. Is possible to traverse within a projection to refer neightbor classes by chaining edge syntax expressions (i.e. {{{in[However, consider that multiple results from a projection traversed from pivot class will be returned as a collection within the result set (unless is a single value).</li>
<li>filtering conditions in the "WHERE" clause are also referred to the pivot class. It is also possible to traverse to neightbor classes in order to compose advanced conditions by using edge syntax expressions (e.g. <code>and in<a href="label='office'%5D.out.out%5Blabel='office'%5D.size(">label='company'</a></code>).).out.out[IN '0000345'}}}).</li>
<li>the 'ORDER BY' clause will be referred to one of the projections and must be returned as a single value per record (i.e. an attribute of the pivot class or a single attribute of a neighbor class). It will not be possible to order by traversed projections in a single query if they return multiple results (as a collection). Therefore, in queries using "ORDER BY" clause, there is not possible choice of the pivot class as it most be the one containing the attribute to ORDER BY.</li>
</ul><p>Additionally, there are performance considerations that should be considered on selecting the pivot class. Assuming 2 classes as follows:</p>

<p>65205b66ddede24ec097328bc88a7b84</p>

<p>Queries:
1. <code>select <a href="label='employee'%5D.in.id">...</a> from CountryType from [1. <code>select <a href="...%5D%3C/code">...</a> from PersonType from [...]</code>}</code></p>

<p>The query (1) will intend to apply the "where" filtering and projections to less number of vertices and, therefore will perform faster that the query (2). Therefore, it is advisable to assign the pivot class to the class with higher average of items relevant for the query to remove unnecessary loops from the evaluation, i.e. usually the one with lower multiplicity.</p>

<h3>Switching the pivot class within a query</h3>

<p>According to previous discussion, is possible to find conflicting requirements on determining the pivot class. Suppose the case where we need to 'ORDER BY' a class with a very high multiplicity (say, millions of vertices), but most of these vertices are not relevant for the outcome of our query.</p>

<p>On one hand, according to the requirements of the 'ORDER BY' clause, we are forced to choose the class containing the attribute to order by, as the pivot class. But, as commented, this class can not be an optimal choice from a performance point of view if only a small subset of vertices is relevant to the query. In this case, we have a design conflict between having a poor performance by setting the pivot class as the class containing the attribute to order by sentence with higher multiplicity, or get a best performing query by taking out the "ORDER BY" clause and ordering results in the invoking Java code. If we choose to execute the full operation in one query, indices can be used to improve the poor performance, but it would be usually an overkill as a consequence of a bad query planning.</p>

<p>A more elegant solution can be achieved by the technique of nesting queries, as shown below:
</p><div class="highlight"><pre>  <span class="n">SELECT</span>
    <span class="n">in</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="err">'</span><span class="n">city</span><span class="err">'</span><span class="o">].</span><span class="na">out</span><span class="o">.</span><span class="na">name</span> <span class="n">AS</span> <span class="n">name</span><span class="o">,</span>
    <span class="n">in</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="err">'</span><span class="n">city</span><span class="err">'</span><span class="o">].</span><span class="na">out</span><span class="o">.</span><span class="na">out</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="err">'</span><span class="n">city</span><span class="err">'</span><span class="o">].</span><span class="na">size</span><span class="o">()</span> <span class="n">AS</span> <span class="n">count_of_cities</span><span class="o">,</span>
    <span class="n">CityLat</span><span class="o">,</span>
    <span class="n">CityLong</span><span class="o">,</span>
    <span class="n">distance</span><span class="o">(</span><span class="n">CityLat</span><span class="o">,</span> <span class="n">CityLong</span><span class="o">,</span> <span class="mf">51.513363</span><span class="o">,-</span><span class="mf">0.089178</span><span class="o">)</span> <span class="n">AS</span> <span class="n">distance</span>
  <span class="n">FROM</span> <span class="o">(</span> 
    <span class="n">SELECT</span> <span class="nf">flatten</span><span class="o">(</span> <span class="n">in</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="err">'</span><span class="n">region</span><span class="err">'</span><span class="o">].</span><span class="na">out</span><span class="o">.</span><span class="na">out</span><span class="o">[</span><span class="n">label</span><span class="o">=</span><span class="err">'</span><span class="n">city</span><span class="err">'</span><span class="o">].</span><span class="na">in</span> <span class="o">)</span>
    <span class="n">FROM</span> <span class="n">CountryType</span> <span class="n">WHERE</span> <span class="n">id</span> <span class="n">IN</span> <span class="err">'</span><span class="mi">0032</span><span class="err">'</span>
  <span class="o">)</span> <span class="n">WHERE</span>
    <span class="n">CityLat</span> <span class="o">&lt;&gt;</span> <span class="err">''</span> <span class="n">AND</span>
    <span class="n">CityLong</span>  <span class="o">&lt;&gt;</span> <span class="err">''</span>
    <span class="n">ORDER</span> <span class="n">BY</span> <span class="n">distance</span>
</pre></div>
This nested query represents a two-fold operation, taking best of both worlds. The first subquery (in red) uses the class with lower multiplicity as pivot class, so the number of required loops is smaller, and as a result, delivers a better performance. The resulting set of vertices from the first subquery, which includes the ordering parameter (in blue), (allowing the ORDER BY operation), is taken as pivot class for the second subquery. The flatten() function is required to expose items from the first subquery as a flat structure to the second query. The higher the multiplicity and number of no relevant records in the class with the parameter to "ORDER BY", the more convenient becomes using this approach.


  </div>

</div>

<footer>
  <div class="row">
    <div class="six columns">
      <ul class="inline-list">
        <li><a href="/orientdb/"> Home</a></li>
<li><a href="/orientdb/about.html"> About</a></li>
<li class="active"><a href="/orientdb/wiki/Home.html"> Documentation</a></li>
<li><a href="/orientdb/wiki/Download.html"> Downloads</a></li>
<li><a href="/orientdb/community.html"> Community</a></li>
      </ul>
    </div>
    <div class="six columns">
      <p class="copyright">
        Copyright &copy; 2011-2012 NuvolaBase Ltd. <br/>
        <span class="small">NuvolaBase is a registered trademark. All Rights Reserved.</span>
      </p>
    </div>
  </div>
</footer>

<script src="../javascripts/app.js" type="text/javascript"></script>

</body>
</html>