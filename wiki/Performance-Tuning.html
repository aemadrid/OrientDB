<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en"><![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" lang="en" xmlns="http://www.w3.org/1999/html"><!--<![endif]-->
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width" />
  <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
  <title>Performance Tuning |  OrientDB</title>
  <title>Performance Tuning</title>
  <link href="../stylesheets/foundation.min.css" media="screen" rel="stylesheet" type="text/css" />
<link href="../stylesheets/app.css" media="screen" rel="stylesheet" type="text/css" />
  <script src="../javascripts/modernizr.foundation.js" type="text/javascript"></script>
  
</head>
<body class="wiki wiki_Performance-Tuning">

<header>
  <div class="row">
    <div class="five columns">
      <h1>
        <a href="/">
          Orient<span class="highl">DB</span>
        </a>
        <span class="subtitle">The Document/Graph NoSQL Database</span>
      </h1>
    </div>
    <div class="seven columns right">
      <ul class="inline-list">
        <li><a href="/"> Home</a></li>
<li><a href="/about.html"> About</a></li>
<li class="active"><a href="/wiki/Home.html"> Documentation</a></li>
<li><a href="/wiki/Download.html"> Downloads</a></li>
<li><a href="/community.html"> Community</a></li>
      </ul>
    </div>
  </div>
</header>


<div class="page-header">
  <div class="row">
    <div class="twelve columns">
      <h2>
        <i class="icon-wiki"></i>
        Performance Tuning
        
          <ul class="bcs">
          
            <li><a href="/wiki/Home.html" class="nr1">Home</a></li>
          
          </ul>
        
        
      </h2>
    </div>
  </div>
</div>

<div id="main" class="row wiki">

  <div class="twelve columns content" role="content">

    <h3>Introduction</h3>

<p>This guide contains the general tips to optimize your application that use the OrientDB. Below you can find links for the specific guides different per database type used.</p>

<ul>
<li><a class="internal present" href="/wiki/Performance-Tuning-Document.html">Document Database performance tuning</a></li>
<li><a class="internal present" href="/wiki/Performance-Tuning-Object.html">Object Database performance tuning</a></li>
<li><a class="internal present" href="/wiki/Performance-Tuning-Graph.html">Graph Database performance tuning</a></li>
<li><a class="internal present" href="/wiki/Performance-Tuning-Blueprints.html">TinkerPop Blueprints Graph Database performance tuning</a></li>
</ul><h3>General settings</h3>

<h4>JVM settings</h4>

<p>The JVM settings suggested when you run your application that uses OrientDB are:
</p><div class="highlight"><pre>  <span class="o">-</span><span class="n">server</span> <span class="o">-</span><span class="nl">XX:</span><span class="o">+</span><span class="n">AggressiveOpts</span> <span class="o">-</span><span class="nl">XX:</span><span class="n">CompileThreshold</span><span class="o">=</span><span class="mi">200</span>
</pre></div>

<h4>Configuration</h4>

<p>OrientDB can be configured in several ways. To know the current configuration use the console with the <a class="internal present" href="/wiki/Console-Command-Config.html">config command</a>.</p>

<p>To dump the OrientDB configuration you can set a parameter at JVM launch:</p>

<div class="highlight"><pre>  <span class="n">java</span> <span class="o">-</span><span class="n">Denvironment</span><span class="o">.</span><span class="na">dumpCfgAtStartup</span><span class="o">=</span><span class="kc">true</span> <span class="o">...</span>
</pre></div>

<p>Or via API at any time:</p>

<div class="highlight"><pre>  <span class="n">OGlobalConfiguration</span><span class="o">.</span><span class="na">dumpConfiguration</span><span class="o">(</span><span class="n">System</span><span class="o">.</span><span class="na">out</span><span class="o">);</span>
</pre></div>

<h5>By command line</h5>

<div class="highlight"><pre><span class="n">java</span> <span class="o">-</span><span class="n">Dcache</span><span class="p">.</span><span class="nb">size</span><span class="p">=</span>10000 <span class="o">-</span><span class="n">Dstorage</span><span class="p">.</span><span class="n">keepOpen</span><span class="p">=</span><span class="n">true</span> <span class="p">...</span>
</pre></div>

<h5>By server configuration</h5>

<p>Put in the <code>&lt;properties&gt;</code> section of the file <strong>orientdb-server-config.xml</strong> the entries to configure. Example:
</p><div class="highlight"><pre>    <span class="o">...</span>
    <span class="o">&lt;</span><span class="n">properties</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">entry</span> <span class="n">name</span><span class="o">=</span><span class="s">"cache.size"</span> <span class="n">value</span><span class="o">=</span><span class="s">"10000"</span> <span class="o">/&gt;</span>
      <span class="o">&lt;</span><span class="n">entry</span> <span class="n">name</span><span class="o">=</span><span class="s">"storage.keepOpen"</span> <span class="n">value</span><span class="o">=</span><span class="s">"true"</span> <span class="o">/&gt;</span>
    <span class="o">&lt;/</span><span class="n">properties</span><span class="o">&gt;</span>
    <span class="o">...</span>
</pre></div>

<h5>At run-time</h5>

<div class="highlight"><pre>    <span class="n">OGlobalConfiguration</span><span class="o">.</span><span class="na">MVRBTREE_NODE_PAGE_SIZE</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="mi">2048</span><span class="o">);</span>
</pre></div>

<h5>Parameters</h5>

<p>To know more look at the Java enum: <a href="http://code.google.com/p/orient/source/browse/trunk/core/src/main/java/com/orientechnologies/orient/core/config/OGlobalConfiguration.java">OGlobalConfiguration.java</a>.</p>

<table><tbody>
<tr>
<th>Area</th>
<th>Parameter</th>
<th>Default 32bit</th>
<th>Default 64bit</th>
<th>Default Server 32bit</th>
<th>Default Server 64bit</th>
<th>Allowed input</th>
<th>Description</th>
<th>Since</th>
</tr>
<tr>
<td>Environment</td>
<td><code>environment.dumpCfgAtStartup</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Dumps the configuration at application startup</td>
</tr>
<tr>
<td>Environment</td>
<td><code>environment.concurrent</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Specifies if running in multi-thread environment. Setting this to false turns off the internal lock management</td>
</tr>
<tr>
<td>Memory</td>
<td><code>memory.optimizeThreshold</code></td>
<td>0.85</td>
<td>0.85</td>
<td>0.85</td>
<td>0.85</td>
<td>0.5-0.95</td>
<td>Threshold of heap memory where to start the optimization of memory usage. Deprecated since 1.0rc7 </td>
</tr>
<tr>
<td>Storage</td>
<td><code>storage.keepOpen</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Tells to the engine to not close the storage when a database is closed. Storages will be closed when the process will shutdown </td>
</tr>
<tr>
<td>Storage</td>
<td><code>storage.record.lockTimeout</code></td>
<td>5000</td>
<td>5000</td>
<td>5000</td>
<td>5000</td>
<td>0-N</td>
<td>Maximum timeout in milliseconds to lock a shared record </td>
</tr>
<tr>
<td>Cache</td>
<td><code>cache.level1.enabled</code></td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Uses the level-1 cache</td>
</tr>
<tr>
<td>Cache</td>
<td><code>cache.level1.size</code></td>
<td>-1</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>-1 - N</td>
<td>Size of the Level-1 cache in terms of record entries. -1 means no limit but when the free Memory Heap is low then cache entries are freed</td>
</tr>
<tr>
<td>Cache</td>
<td><code>cache.level2.enabled</code></td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Uses the level-2 cache</td>
</tr>
<tr>
<td>Cache</td>
<td><code>cache.level2.size</code></td>
<td>-1</td>
<td>-1</td>
<td>0</td>
<td>0</td>
<td>-1 - N</td>
<td>Size of the Level-2 cache in terms of record entries. -1 means no limit but when the free Memory Heap is low then cache entries are freed</td>
</tr>
<tr>
<td>Database</td>
<td><code>db.mvcc</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Enable Multi Version Control Checking (MVCC) or not</td>
</tr>
<tr>
<td>Database</td>
<td><code>object.saveOnlyDirty</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Object Database saves only object bound to dirty records</td>
</tr>
<tr>
<td>Database</td>
<td><code>nonTX.recordUpdate.synch</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Executes a synch against the file-system at every record operation. This slows down records updates but guarantee reliability on unreliable drives</td>
</tr>
<tr>
<td>Transaction</td>
<td><code>tx.useLog</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Transactions use log file to store temporary data to being rollbacked in case of crash</td>
</tr>
<tr>
<td>Transaction</td>
<td><code>tx.log.fileType</code></td>
<td>classic</td>
<td>classic</td>
<td>classic</td>
<td>classic</td>
<td>'classic' or 'mmap'</td>
<td>File type to handle transaction logs: mmap or classic</td>
</tr>
<tr>
<td>Transaction</td>
<td><code>tx.log.synch</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Executes a synch against the file-system for each log entry. This slows down transactions but guarantee transaction reliability on non-reliable drives</td>
</tr>
<tr>
<td>Transaction</td>
<td><code>tx.commit.synch</code></td>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Synchronizes the storage after transaction commit (see [Disable the disk synch](#Disable_the_disk_synch))</td>
</tr>
<tr>
<td><a class="internal present" href="/wiki/Graph-Database-Tinkerpop.html">TinkerPop Blueprints</a></td>
<td><code>blueprints.graph.txMode</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0 or 1</td>
<td>Transaction mode used in <a class="internal present" href="/wiki/Graph-Database-Tinkerpop.html">TinkerPop Blueprints</a> implementation. 0 = Automatic (default), 1 = Manual</td>
</tr>
<tr>
<td>Index</td>
<td><code>index.auto.rebuildAfterNotSoftClose</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>Auto rebuild all automatic indexes after upon database open when wasn't closed propertly</td>
<td>1.3.0</td>
</tr>
<tr>
<td>MVRB Tree (index and dictionary)</td>
<td><code>mvrbtree.lazyUpdates</code></td>
<td>20000</td>
<td>20000</td>
<td>1</td>
<td>1</td>
<td>-1=Auto, 0=always lazy until express lazySave() is called by application, 1=No lazy, commit at each change. &gt;1=Commit at every X changes</td>
<td>Configure the MVRB Trees (indexes and dictionaries) as buffered or not</td>
</tr>
<tr>
<td>MVRB Tree (index and dictionary)</td>
<td><code>mvrbtree.nodePageSize</code></td>
<td>128</td>
<td>128</td>
<td>128</td>
<td>128</td>
<td>63-65535</td>
<td>Page size of each single node. 1,024 means that 1,024 entries can be stored inside a node</td>
</tr>
<tr>
<td>MVRB Tree (index and dictionary)</td>
<td><code>mvrbtree.loadFactor</code></td>
<td>0.7f</td>
<td>0.7f</td>
<td>0.7f</td>
<td>0.7f</td>
<td>0.1-0.9</td>
<td>HashMap load factor</td>
</tr>
<tr>
<td>MVRB Tree (index and dictionary)</td>
<td><code>mvrbtree.optimizeThreshold</code></td>
<td>200000</td>
<td>200000</td>
<td>200000</td>
<td>200000</td>
<td>10-N</td>
<td>Auto optimize the MVRB Tree every X operations as get, put and remove. -1=Auto (default)</td>
</tr>
<tr>
<td>MVRB Tree (index and dictionary)</td>
<td><code>mvrbtree.entryPoints</code></td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>1-200</td>
<td>Number of entry points to start searching entries</td>
</tr>
<tr>
<td>MVRB Tree (index and dictionary)</td>
<td><code>mvrbtree.optimizeEntryPointsFactor</code></td>
<td>1.0f</td>
<td>1.0f</td>
<td>1.0f</td>
<td>1.0f</td>
<td>0.1-N</td>
<td> Multiplicand factor to apply to entry-points list (parameter <code>mvrbtree.entrypoints</code>) to determine if needs of optimization</td>
</tr>
<tr>
<td>MVRB Tree RIDs (index and dictionary)</td>
<td><code>mvrbtree.ridBinaryThreshold</code></td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>8</td>
<td>-1 - N</td>
<td>Valid for set of rids. It's the threshold as number of entries to use the binary streaming instead of classic string streaming. -1 means never use binary streaming</td>
</tr>
<tr>
<td>MVRB Tree RIDs (index and dictionary)</td>
<td><code>mvrbtree.ridNodePageSize</code></td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>16</td>
<td>4 - N</td>
<td>Page size of each treeset node. 16 means that 16 entries can be stored inside each node</td>
</tr>
<tr>
<td>MVRB Tree RIDs (index and dictionary)</td>
<td><code>mvrbtree.ridNodeSaveMemory</code></td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>False</td>
<td>true or false</td>
<td>Save memory usage by avoid keeping RIDs in memory but creating them at every access</td>
</tr>
<tr>
<td>Lazy Collections</td>
<td><code>lazyset.workOnStream</code></td>
<td>true</td>
<td>true</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Work directly on streamed buffer to reduce memory footprint and improve performance</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.lock</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Locks the used files so other process can't modify them</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.defrag.strategy</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0,1</td>
<td>Strategy to recycle free space. 0=recycles the first hole with enough size (default): fast, 1=recycles the best hole: better usage of space but slower</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.defrag.holeMaxDistance</code></td>
<td>32768 (32Kb)</td>
<td>32768 (32Kb)</td>
<td>32768 (32Kb)</td>
<td>32768 (32Kb)</td>
<td>8K-N</td>
<td>Max distance in bytes between holes to execute the defrag of them. Set it to -1 to use dynamic size. Pay attention that is db is huge, then moving blocks to defrag could be expensive</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.useOldManager</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Manager that will be used to handle mmap files. true = USE OLD MANAGER, false = USE NEW MANAGER</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.lockMemory</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>When using new map manager this parameter specify prevent memory swap or not. true = LOCK MEMORY, false = NOT LOCK MEMORY(If you want this parameter take effect you need to have Orient Native OS jar in class path)</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.strategy</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0-4</td>
<td>Strategy to use with memory mapped files. 0 = USE MMAP ALWAYS, 1 = USE MMAP ON WRITES OR ON READ JUST WHEN THE BLOCK POOL IS FREE, 2 = USE MMAP ON WRITES OR ON READ JUST WHEN THE BLOCK IS ALREADY AVAILABLE, 3 = USE MMAP ONLY IF BLOCK IS ALREADY AVAILABLE, 4=NEVER USE MMAP</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.blockSize</code></td>
<td>1048576 (1Mb)</td>
<td>1048576 (1Mb)</td>
<td>1048576 (1Mb)</td>
<td>1048576 (1Mb)</td>
<td>10k-N</td>
<td>Size of the memory mapped block(this property takes effect only if file.mmap.useOldManager is set up to true)</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.bufferSize</code></td>
<td>8192 (8Kb)</td>
<td>8192 (8Kb)</td>
<td>8192 (8Kb)</td>
<td>8192 (8Kb)</td>
<td>1K-N</td>
<td>Size of the buffer for direct access to the file through the channel(this property takes effect only if file.mmap.useOldManager is set up to true)</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.maxMemory</code></td>
<td>134217728 (134Mb)</td>
<td>(maxOsMemory - maxProcessHeapMemory) / 2</td>
<td>134217728 (134Mb)</td>
<td>(maxOsMemory - maxProcessHeapMemory) / 2</td>
<td>100000-the maximum allowed by OS</td>
<td>Max memory allocable by memory mapping manager. Note that on 32bit OS the limit is to 2Gb but can change to OS by OS(this property takes effect only if file.mmap.useOldManager is set up to true)</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.overlapStrategy</code></td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>2</td>
<td>0-2</td>
<td>Strategy when a request overlap in-memory buffers: 0 = Use the channel access, 1 = force the in memory buffer and use the channel access, 2 = always create an overlapped in-memory buffer (default) (this property takes effect only if file.mmap.useOldManager is set up to true)</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.forceDelay</code></td>
<td>500 (0.5sec)</td>
<td>500 (0.5sec)</td>
<td>500 (0.5sec)</td>
<td>500 (0.5sec)</td>
<td>100-5000</td>
<td>Delay time in ms to wait for another force flush of the memory mapped block to the disk</td>
</tr>
<tr>
<td>File (I/O)</td>
<td><code>file.mmap.forceRetry</code></td>
<td>20</td>
<td>20</td>
<td>20</td>
<td>20</td>
<td>0-N</td>
<td>Number of times the memory mapped block will try to flush to the disk</td>
</tr>
<tr>
<td>JNA</td>
<td><code>jna.disable.system.library</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>This property disable to using JNA installed in your system. And use JNA bundled with database.</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.socketBufferSize</code></td>
<td>32768</td>
<td>32768</td>
<td>32768</td>
<td>32768</td>
<td>8K-N</td>
<td>TCP/IP Socket buffer size</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.lockTimeout</code></td>
<td>15000 (15secs)</td>
<td>15000 (15secs)</td>
<td>15000 (15secs)</td>
<td>15000 (15secs)</td>
<td>0-N</td>
<td>Timeout in ms to acquire a lock against a channel, 0=no timeout</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.socketTimeout</code></td>
<td>10000 (10secs)</td>
<td>10000 (10secs)</td>
<td>10000 (10secs)</td>
<td>10000 (10secs)</td>
<td>0-N</td>
<td>TCP/IP Socket timeout in ms, 0=no timeout</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.retry</code></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>0-N</td>
<td>Number of times the client connection retries to connect to the server in case of failure</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.retryDelay</code></td>
<td>500 (0.5sec)</td>
<td>500 (0.5sec)</td>
<td>500 (0.5sec)</td>
<td>500 (0.5sec)</td>
<td>1-N</td>
<td>Number of ms the client wait to reconnect to the server in case of failure</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.binary.maxLength</code></td>
<td>100000 (100Kb)</td>
<td>100000 (100Kb)</td>
<td>100000 (100Kb)</td>
<td>100000 (100Kb)</td>
<td>1K-N</td>
<td>TCP/IP max content length in bytes of BINARY requests</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.binary.readResponse.maxTime</code></td>
<td>30</td>
<td>30</td>
<td>30</td>
<td>30</td>
<td>0-N</td>
<td>Maximum time (in seconds) to wait until response will be read. Otherwise response will be dropped from chanel</td>
<td>1.0rc9</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.binary.debug</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Debug mode: print all the incoming data on binary channel</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.http.maxLength</code></td>
<td>100000 (100Kb)</td>
<td>100000 (100Kb)</td>
<td>100000 (100Kb)</td>
<td>100000 (100Kb)</td>
<td>1000-N</td>
<td>TCP/IP max content length in bytes of HTTP requests</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.http.charset</code></td>
<td>utf-8</td>
<td>utf-8</td>
<td>utf-8</td>
<td>utf-8</td>
<td>Supported HTTP charsets</td>
<td>Http response charset</td>
</tr>
<tr>
<td>Networking (I/O)</td>
<td><code>network.http.sessionExpireTimeout</code></td>
<td>300 (5min)</td>
<td>300 (5min)</td>
<td>300 (5min)</td>
<td>300 (5min)</td>
<td>0-N</td>
<td>Timeout to consider a http session expired in seconds</td>
</tr>
<tr>
<td><a class="internal present" href="/wiki/Profiler.html">Profiler</a></td>
<td><code>profiler.enabled</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Enable the recording of statistics and counters</td>
</tr>
<tr>
<td><a class="internal present" href="/wiki/Profiler.html">Profiler</a></td>
<td><code>profiler.autoDump.interval</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0=inactive &gt;0=time in seconds</td>
<td>Dumps the profiler values at regular intervals. Time is expressed in seconds</td>
<td>1.0rc8</td>
</tr>
<tr>
<td><a class="internal present" href="/wiki/Profiler.html">Profiler</a></td>
<td><code>profiler.autoDump.reset</code></td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true or false</td>
<td>Resets the profiler at every auto dump</td>
<td>1.0rc8</td>
</tr>
<tr>
<td><a class="internal present" href="/wiki/Profiler.html">Profiler</a></td>
<td><code>profiler.config</code></td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>null</td>
<td>String with 3 values separated by comma with the format: <code>&lt;seconds-for-snapshot&gt;,&lt;archive-snapshot-size&gt;,&lt;summary-size&gt;</code>
</td>
<td>Configure the profiler</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Log</td>
<td><code>log.console.level</code></td>
<td>info</td>
<td>info</td>
<td>info</td>
<td>info</td>
<td>fine, info, warn, error</td>
<td>Console's logging level</td>
</tr>
<tr>
<td>Log</td>
<td><code>log.file.level</code></td>
<td>fine</td>
<td>fine</td>
<td>fine</td>
<td>fine</td>
<td>fine, info, warn, error</td>
<td>File's logging level</td>
</tr>
<tr>
<td>Client</td>
<td><code>client.channel.minPool</code></td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1-N</td>
<td>Minimum size of the channel pool</td>
</tr>
<tr>
<td>Client</td>
<td><code>client.channel.maxPool</code></td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>5</td>
<td>1-N</td>
<td>maximum size of the channel pool</td>
</tr>
<tr>
<td>Server</td>
<td><code>server.channel.cleanDelay</code></td>
<td>5000</td>
<td>5000</td>
<td>5000</td>
<td>5000</td>
<td>0-N</td>
<td>Time in ms of delay to check pending closed connections</td>
<td>1.0</td>
</tr>
<tr>
<td>Server</td>
<td><code>server.log.dumpClientExceptionLevel</code></td>
<td>FINE</td>
<td>FINE</td>
<td>FINE</td>
<td>FINE</td>
<td>OFF, FINE, CONFIG, INFO, WARNING, SEVERE</td>
<td>Logs client exceptions. Use any level supported by Java java.util.logging.Level class</td>
<td>1.0</td>
</tr>
<tr>
<td>Server</td>
<td><code>server.log.dumpClientExceptionFullStackTrace</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Dumps the full stack trace of the exception to sent to the client</td>
<td>1.0</td>
</tr>
<tr>
<td>Server</td>
<td><code>server.cache.staticFile</code></td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>true or false</td>
<td>Cache static resources after loaded. It was <code>server.cache.file.static</code> before 1.0</td>
</tr>
<tr>
<td>Distributed cluster</td>
<td><code>distributed.async.timeDelay</code></td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0-N</td>
<td>Delay time (in ms) of synchronization with slave nodes. 0 means early synchronization</td>
</tr>
<tr>
<td>Distributed cluster</td>
<td><code>distributed.sync.maxRecordsBuffer</code></td>
<td>100</td>
<td>100</td>
<td>100</td>
<td>100</td>
<td>0-10000</td>
<td>Maximum number of records to buffer before to send to the slave nodes</td>
</tr>
</tbody></table><p><em>NOTE: On 64-bit systems you have not the limitation of 32-bit systems with memory.</em></p>

<h4>Memory optimization</h4>

<p>What can makes the difference is the right balancing between the heap and the virtual memory used by Memory Mapping, specially on large datasets (GBs, TBs and more) where the in memory cache structures count less than raw IO.</p>

<p>For example if you can assign 4GB to the Java process, it could be better assigning small heap and large Virtual Memory. Rather than:</p>

<div class="highlight"><pre>  <span class="n">java</span> <span class="o">-</span><span class="n">Xmx4g</span> <span class="o">...</span>
</pre></div>
You could instead try this:
<div class="highlight"><pre>  <span class="n">java</span> <span class="o">-</span><span class="n">Xmx800m</span> <span class="o">-</span><span class="n">Dfile</span><span class="o">.</span><span class="na">mmap</span><span class="o">.</span><span class="na">maxMemory</span><span class="o">=</span><span class="mf">3.2</span><span class="n">gb</span> <span class="o">...</span>
</pre></div>

<p>The parameter <strong>file.mmap.maxMemory</strong> tells how much memory to use for the Memory Mapping at the storage level. The default value for 32-bit systems is very tiny (134 Mb) but with 32-bit architecture you have a lot of limitation and you need to pay attention to set it too large. On 64 bit systems I suggest to set it to: <code>( os tot memory - orientdb heap ) * 85%</code>. 85% should be reduced when you're running other memory expensive process on your OS.</p>

<p>On 64 bit systems the default value is <code>(maxOsMemory - maxProcessHeapMemory) / 2</code>.</p>

<p><em>NOTE: If you use too much memory your system will goes in swap and the entire machine will slow down. Play with this parameter in order to find the best value for your configuration.</em></p>

<h4>File System access strategy</h4>

<p>This is more technical. It tells to the storage engine the strategy to use when access to the file system. Previous versions always used the 0 strategy, namely uses Memory Mapping techniques for all. Mode 1 tells to use Memory Mapping but on reads only if there is room in memory, otherwise regular Java NIO file channel read will be used. The strategy 2 is more conservative since reads will use Memory Mapping only if the requested data has already been loaded in memory. The strategy 3 means use Memory Mapping until there is space in the pool, then use regular Java NIO file channel read/write. Strategy 4 means don't use Memory Mapping at all.</p>

<p>By default the strategy 1 is used, but feel free to test the others to know what is the best for your use case.</p>

<h3>Remote connections</h3>

<p>There are many ways to improve performance when you access to the database using the remote connection.</p>

<h4>Network Connection Pool</h4>

<p>Each client, by default, uses only one network connection to talk with the server. Multiple threads on the same client share the same network connection pool.</p>

<p>When you've multiple threads could be a bottleneck since a lot of time is spent on waiting for a free network connection. This is the reason why is much important to configure the network connection pool.</p>

<p>The configurations is very simple, just 2 parameters:</p>

<ul>
<li>
<strong>minPool</strong>, is the initial size of the connection pool. The default value is configured as global parameters "client.channel.minPool" (see <a href="#Parameters">parameters</a>)</li>
<li>
<strong>maxPool</strong>, is the maximum size the connection pool can reach. The default value is configured as global parameters "client.channel.maxPool" (see <a href="#Parameters">parameters</a>)</li>
</ul><p>At first connection the <strong>minPool</strong> is used to pre-create network connections against the server. When a client thread is asking for a connection and all the pool is busy, then it tries to create a new connection until <strong>maxPool</strong> is reached.</p>

<p>If all the pool connections are busy, then the client thread will wait for the first free connection.</p>

<p>Example of configuration by using database properties:
</p><div class="highlight"><pre>  <span class="n">database</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ODatabaseDocumentTx</span><span class="o">(</span><span class="s">"remote:localhost/demo"</span><span class="o">);</span>
  <span class="n">database</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"minPool"</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
  <span class="n">database</span><span class="o">.</span><span class="na">setProperty</span><span class="o">(</span><span class="s">"maxPool"</span><span class="o">,</span> <span class="mi">5</span><span class="o">);</span>
  
  <span class="n">database</span><span class="o">.</span><span class="na">open</span><span class="o">(</span><span class="s">"admin"</span><span class="o">,</span> <span class="s">"admin"</span><span class="o">);</span>
</pre></div>

<h4>Enlarge timeouts</h4>

<p>If you see a lot of messages like:
</p><div class="highlight"><pre>  <span class="nl">WARNIGN:</span> <span class="n">Connection</span> <span class="n">re</span><span class="o">-</span><span class="n">acquired</span> <span class="n">transparently</span> <span class="n">after</span> <span class="n">XXXms</span> <span class="n">and</span> <span class="n">Y</span> <span class="nl">retries:</span> <span class="n">no</span> <span class="n">errors</span> <span class="n">will</span> <span class="n">be</span> <span class="n">thrown</span> <span class="n">at</span> <span class="n">application</span> <span class="n">level</span> 
</pre></div>
means that probably default timeouts are too low and server side operation need more time to complete. It's strongly suggested you enlarge your timeout only after tried to enlarge the <a href="#Network_Connection_Pool">Network Connection Pool</a>. The timeout parameters to tune are:

<ul>
<li>
<code>network.lockTimeout</code>, the timeout in ms to acquire a lock against a channel. The default is 15 seconds.</li>
<li>
<code>network.socketTimeout</code>, the TCP/IP Socket timeout in ms. The default is 10 seconds.</li>
</ul><h3>Query</h3>

<h4>Use of indexes</h4>

<p>The first improvement to speed up queries is to create <a class="internal present" href="/wiki/Indexes.html">Indexes</a> against the fields used in WHERE conditions. For example this query:
</p><div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="n">Profile</span> <span class="n">WHERE</span> <span class="n">name</span> <span class="o">=</span> <span class="err">'</span><span class="n">Jay</span><span class="err">'</span> 
</pre></div>
Browses the entire "profile" cluster looking for records that satisfy the conditions. The solution is to create an index against the 'name' property with:
<div class="highlight"><pre>  <span class="n">CREATE</span> <span class="n">INDEX</span> <span class="n">profile</span><span class="o">.</span><span class="na">name</span> <span class="n">UNIQUE</span>
</pre></div>

<p>Use NOTUNIQUE instead of UNIQUE if the value is not unique.</p>

<p>For more complex queries like
</p><div class="highlight"><pre>  <span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">testClass</span> <span class="n">where</span> <span class="n">prop1</span> <span class="o">=</span> <span class="o">?</span> <span class="n">and</span> <span class="n">prop2</span> <span class="o">=</span> <span class="o">?</span>
</pre></div>
Composite index should be used
<div class="highlight"><pre>  <span class="n">CREATE</span> <span class="n">INDEX</span> <span class="n">compositeIndex</span> <span class="n">ON</span> <span class="nf">testClass</span> <span class="o">(</span><span class="n">prop1</span><span class="o">,</span> <span class="n">prop2</span><span class="o">)</span> <span class="n">UNIQUE</span>
</pre></div>
or via Java API:
<div class="highlight"><pre>  <span class="n">oClass</span><span class="o">.</span><span class="na">createIndex</span><span class="o">(</span><span class="s">"compositeIndex"</span><span class="o">,</span> <span class="n">OClass</span><span class="o">.</span><span class="na">INDEX_TYPE</span><span class="o">.</span><span class="na">UNIQUE</span><span class="o">,</span> <span class="s">"prop1"</span><span class="o">,</span> <span class="s">"prop2"</span><span class="o">);</span>
</pre></div>
Moreover, because of partial match searching, this index will be used for optimizing query like 
<div class="highlight"><pre>  <span class="n">select</span> <span class="o">*</span> <span class="n">from</span> <span class="n">testClass</span> <span class="n">where</span> <span class="n">prop1</span> <span class="o">=</span> <span class="o">?</span>
</pre></div>

<p>For deep understanding of query optimization look at the unit test:
<a href="http://code.google.com/p/orient/source/browse/trunk/tests/src/test/java/com/orientechnologies/orient/test/database/auto/SQLSelectIndexReuseTest.java">http://code.google.com/p/orient/source/browse/trunk/tests/src/test/java/com/orientechnologies/orient/test/database/auto/SQLSelectIndexReuseTest.java</a></p>

<h4>Right usage of the graph</h4>

<p>OrientDB is a graph database. This means that traversing is very efficient. You can use this feature to optimize queries. A common technique is the <a class="internal present" href="/wiki/Pivoting-With-Query.html">Pivoting</a>.</p>

<h4>Avoid use of @rid in WHERE conditions</h4>

<p>Using <strong>@rid</strong> in where conditions slow down queries. Much better to use the <a class="internal present" href="/wiki/Concepts.html#recordid">RecordID</a> as target. Example:</p>

<p>Change this:
</p><div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="n">Profile</span> <span class="n">WHERE</span> <span class="nd">@rid</span> <span class="o">=</span> <span class="err">#</span><span class="mi">10</span><span class="o">:</span><span class="mi">44</span>
</pre></div>
With this:
<div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="err">#</span><span class="mi">10</span><span class="o">:</span><span class="mi">44</span>
</pre></div>
Also 
<div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="n">Profile</span> <span class="n">WHERE</span> <span class="nd">@rid</span> <span class="n">IN</span> <span class="o">[</span><span class="err">#</span><span class="mi">10</span><span class="o">:</span><span class="mi">44</span><span class="o">,</span> <span class="err">#</span><span class="mi">10</span><span class="o">:</span><span class="mi">45</span><span class="o">]</span>
</pre></div>
With this:
<div class="highlight"><pre>  <span class="n">SELECT</span> <span class="n">FROM</span> <span class="o">[</span><span class="err">#</span><span class="mi">10</span><span class="o">:</span><span class="mi">44</span><span class="o">,</span> <span class="err">#</span><span class="mi">10</span><span class="o">:</span><span class="mi">45</span><span class="o">]</span>
</pre></div>

<h3>Massive Insertion</h3>

<h4>Use the Massive Insert intent</h4>

<p>Intents suggest to OrientDB what you're going to do. In this case you're telling to OrientDB that you're executing a massive insertion. OrientDB auto-reconfigure itself to obtain the best performance. When done you can remove the intent just setting it to null.</p>

<p>Example:
</p><div class="highlight"><pre>  <span class="n">db</span><span class="o">.</span><span class="na">declareIntent</span><span class="o">(</span> <span class="k">new</span> <span class="n">OIntentMassiveInsert</span><span class="o">()</span> <span class="o">);</span>
  
  <span class="c1">// YOUR MASSIVE INSERTION</span>
  
  <span class="n">db</span><span class="o">.</span><span class="na">declareIntent</span><span class="o">(</span> <span class="kc">null</span> <span class="o">);</span>
</pre></div>

<h3>Massive Updates</h3>

<p>Updates generates "holes" at Storage level because rarely the new record fits perfectly the size of the previous one. Holes are free spaces between data. Holes are recycled but an excessive number of small holes it's the same as having a highly defragmented File System: space is wasted (because small holes can't be easily recycled) and performance degrades when the database growth.</p>

<h4>Oversize</h4>

<p>If you know you will update certain type of records, create a class for them and set the Oversize (default is 0) to 2 or more.</p>

<p>By default the OGraphVertex class has an oversize value setted at 2. If you define your own classes set this value at least at 2.</p>

<p>OClass myClass = getMetadata().getSchema().createClass("Car");
myClass.setOverSize(2);</p>

<h3>Wise use of transactions</h3>

<p>To obtain real linear performance with OrientDB you should avoid to use <a class="internal present" href="/wiki/Transactions.html">Transactions</a> as far as you can. In facts OrientDB keeps in memory all the changes until you flush it with a commit. So the bottleneck is your Heap space and the management of local transaction cache (implemented as a Map).</p>

<p><a class="internal present" href="/wiki/Transactions.html">Transactions</a> slow down massive inserts unless you're using a "remote" connection. In that case it speeds up all the insertion because the client/server communication happens only at commit time.</p>

<h4>Disable Transaction Log</h4>

<p>If you need to group operations to speed up remote execution in a logical transaction but renouncing to the Transaction Log, just disable it by setting the property <strong>tx.useLog</strong> to false.</p>

<p>Via JVM configuration:
</p><div class="highlight"><pre>  <span class="n">java</span> <span class="o">...</span> <span class="o">-</span><span class="n">Dtx</span><span class="o">.</span><span class="na">useLog</span><span class="o">=</span><span class="kc">false</span> <span class="o">...</span>
</pre></div>
or via API:
<div class="highlight"><pre>  <span class="n">OGlobalConfiguration</span><span class="o">.</span><span class="na">TX_USE_LOG</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</pre></div>

<p><em>NOTE: Please note that in case of crash of the JVM the pending transaction OrientDB could not be able to rollback it.</em></p>


  </div>

</div>

<footer>
  <div class="row">
    <div class="six columns">
      <ul class="inline-list">
        <li><a href="/"> Home</a></li>
<li><a href="/about.html"> About</a></li>
<li class="active"><a href="/wiki/Home.html"> Documentation</a></li>
<li><a href="/wiki/Download.html"> Downloads</a></li>
<li><a href="/community.html"> Community</a></li>
      </ul>
    </div>
    <div class="six columns">
      <p class="copyright">
        Copyright &copy; 2011-2012 NuvolaBase Ltd. <br/>
        <span class="small">NuvolaBase is a registered trademark. All Rights Reserved.</span>
      </p>
    </div>
  </div>
</footer>

<script src="../javascripts/app.js" type="text/javascript"></script>

</body>
</html>